# Divio Documentation System Starter Kit

A practical guide for organizing project documentation using the 4-quadrant framework. Perfect for early-to-mid stage projects.

## Quick Start Guide

The Divio Documentation System organizes all documentation into exactly 4 types. Each type serves a different user need and requires different writing approaches.

**Core Rule:** Keep these 4 types separate. Never mix them in the same document.

```
Learning (Do this)     |  Problem-Solving (Fix this)
   TUTORIALS          |     HOW-TO GUIDES  
  Step-by-step        |    Specific solutions
                      |
Understanding (Why)    |  Reference (Look this up)
   EXPLANATION        |      REFERENCE
  Context & design    |    Technical specs
```

## 1. TUTORIALS - Teaching Through Doing

**Purpose:** Get complete beginners from zero to working result

**Format:** Step-by-step instructions that always work

### Tutorial Template
```
# Tutorial: [Clear outcome - "Build your first API"]

## What you'll build
[Describe the end result - be specific and motivating]

## Prerequisites  
- [List exactly what they need to know/have installed]

## Step 1: [Action verb - "Set up the project"]
[Exact commands/actions - no explanation of why]

## Step 2: [Next action]
[Continue building toward the goal]

## What's next
[Point to relevant how-to guides or explanations]
```

### Tutorial Examples

**Good Tutorial Titles:**
- "Build your first React component in 10 minutes"
- "Create a REST API with Node.js and Express"
- "Deploy your app to Heroku"

**Bad Tutorial Titles:**
- "Understanding React components" (this is explanation)
- "React components" (too vague)
- "Advanced React patterns" (not for beginners)

### Tutorial Checklist
- [ ] Can a complete beginner follow this?
- [ ] Does every step produce a visible result?
- [ ] Does it work every time?
- [ ] Does it build something meaningful?
- [ ] Are explanations minimal?

### Tutorial Code Example
```javascript
// Tutorial: Build a To-Do App with JavaScript

// Step 1: Create the HTML structure
// Add this to your index.html:
<div id="app">
  <input id="todo-input" placeholder="Add a task">
  <button id="add-btn">Add</button>
  <ul id="todo-list"></ul>
</div>

// Step 2: Add basic functionality
// Add this to your script.js:
const input = document.getElementById('todo-input');
const button = document.getElementById('add-btn');
const list = document.getElementById('todo-list');

button.addEventListener('click', function() {
  const li = document.createElement('li');
  li.textContent = input.value;
  list.appendChild(li);
  input.value = '';
});

// Result: You now have a working to-do app
```

## 2. HOW-TO GUIDES - Solving Specific Problems

**Purpose:** Answer "How do I [specific task]?" for users with some experience

**Format:** Goal-oriented steps with flexibility for different situations

### How-to Guide Template
```
# How to [Specific task]

## Problem
[What specific issue this solves]

## Prerequisites
[Assume some knowledge - link to tutorials if needed]

## Solution
1. [Step with some flexibility]
2. [Alternative approaches when relevant]
3. [Expected outcome]

## Variations
[How to adapt for different scenarios]

## Troubleshooting
[Common issues and fixes]
```

### How-to Guide Examples

**Good How-to Titles:**
- "How to add authentication to your API"
- "How to optimize your database queries"
- "How to handle file uploads"

**Bad How-to Titles:**
- "Authentication" (too broad)
- "Getting started with authentication" (that's a tutorial)
- "Why you need authentication" (that's explanation)

### How-to Code Example
```javascript
// How to: Add Error Handling to API Calls

// Problem: API calls can fail, causing your app to break

// Solution 1: Using try/catch with async/await
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null; // Or handle error appropriately
  }
}

// Solution 2: Using .catch() with promises
function fetchUserData(userId) {
  return fetch(`/api/users/${userId}`)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .catch(error => {
      console.error('Failed to fetch user:', error);
      return null;
    });
}

// Usage in your app:
const userData = await fetchUserData(123);
if (userData) {
  // Success case
  displayUser(userData);
} else {
  // Error case
  showErrorMessage('User not found');
}
```

## 3. REFERENCE - Technical Information Lookup

**Purpose:** Comprehensive, accurate technical details

**Format:** Structured information for quick lookup

### Reference Template
```
# [API/Function/Component] Reference

## Overview
[Brief description of what this is]

## Parameters
| Name | Type | Required | Description |
|------|------|----------|-------------|
| param1 | string | Yes | Description |

## Methods/Properties
### method1(param)
**Description:** [What it does]
**Parameters:** [Details]
**Returns:** [What it returns]
**Example:** [Basic usage example]

## Examples
[Minimal usage examples only - no tutorials]
```

### Reference Examples

**Good Reference Sections:**
- "API Endpoints"
- "Configuration Options"
- "Function Reference"
- "Component Props"

### Reference Code Example
```javascript
// API Reference: User Management

// GET /api/users
// Description: Retrieve all users
// Parameters: 
//   - page (optional): Page number, default 1
//   - limit (optional): Items per page, default 10
// Returns: Array of user objects
// Example: fetch('/api/users?page=2&limit=20')

// POST /api/users
// Description: Create a new user
// Body: { name: string, email: string, role?: string }
// Returns: Created user object with ID
// Example: 
fetch('/api/users', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ name: 'John', email: 'john@example.com' })
})

// User Object Schema
{
  id: number,           // Unique identifier
  name: string,         // Full name
  email: string,        // Email address (unique)
  role: string,         // 'admin' | 'user' | 'guest'
  createdAt: string,    // ISO 8601 timestamp
  updatedAt: string     // ISO 8601 timestamp
}
```

## 4. EXPLANATION - Understanding Context

**Purpose:** Help users understand the "why" behind design decisions

**Format:** Discursive, educational content

### Explanation Template
```
# Understanding [Concept/Decision]

## Background
[Why this topic matters]

## The Problem
[What challenge this addresses]

## Our Approach
[How we solved it and why]

## Alternatives
[Other approaches we considered]

## Trade-offs
[What we gained/lost with our decision]

## When to Use
[Guidance on when this applies]
```

### Explanation Examples

**Good Explanation Topics:**
- "Why we chose REST over GraphQL"
- "Understanding our database design"
- "Architecture decisions"
- "Security considerations"

### Explanation Example
```
# Understanding Our Authentication Strategy

## Background
Modern web applications need secure user authentication while maintaining 
good user experience. We evaluated several approaches before settling on 
our current JWT-based system.

## The Problem
Users need to:
- Log in once and stay logged in across sessions
- Access protected resources securely
- Have their sessions expire appropriately

Developers need:
- Stateless authentication (no server-side sessions)
- Easy integration across services
- Reasonable security without complexity

## Our Approach: JWT with Refresh Tokens
We use JWT (JSON Web Tokens) with a refresh token pattern:
- Short-lived access tokens (15 minutes)
- Long-lived refresh tokens (7 days)
- Automatic token refresh in the background

## Why Not Alternatives?

### Server-side sessions
❌ Requires shared session storage across services
❌ Harder to scale horizontally
✅ More secure (can revoke immediately)

### Long-lived JWTs only
❌ Can't revoke tokens before expiration
❌ Security risk if token is compromised
✅ Simpler implementation

### OAuth 2.0 only
❌ Overkill for our use case
❌ Adds external dependencies
✅ Industry standard

## Trade-offs We Accepted
- Slightly more complex client-side code
- 15-minute window where revoked tokens still work
- Need to handle token refresh failures

## When to Reconsider
- If we need immediate session revocation
- If we add multi-tenancy
- If compliance requirements change
```

## Implementation Guide for Your Project

### Phase 1: Audit Your Docs (30 minutes)
1. List all your current documentation
2. Categorize each piece into the 4 types
3. Identify gaps and overlaps

### Phase 2: Quick Wins (1-2 hours)
1. Write 1 simple tutorial for your main use case
2. Create a basic reference for your API/main functions
3. Split any mixed-type documents

### Phase 3: Build Out (ongoing)
1. Add how-to guides for common problems
2. Write explanations for complex decisions
3. Keep tutorials updated and working

### Documentation Structure for Small Projects
```
docs/
├── README.md              # Project overview + quick tutorial
├── tutorials/
│   ├── getting-started.md # Your main tutorial
│   └── advanced-setup.md  # Optional: next-level tutorial
├── how-to/
│   ├── deployment.md      # Common tasks
│   ├── configuration.md
│   └── troubleshooting.md
├── reference/
│   ├── api.md            # Technical specs
│   └── config-options.md
└── explanation/
    ├── architecture.md    # Why decisions
    └── design-principles.md
```

### Documentation Structure for Medium Projects
```
docs/
├── index.md               # Documentation home
├── getting-started/       # Tutorials section
│   ├── quick-start.md
│   ├── installation.md
│   └── first-project.md
├── guides/               # How-to guides
│   ├── deployment/
│   ├── integration/
│   └── troubleshooting/
├── reference/            # Reference docs
│   ├── api/
│   ├── cli/
│   └── configuration/
└── concepts/             # Explanations
    ├── architecture.md
    ├── design-decisions.md
    └── best-practices.md
```

## Common Mistakes to Avoid

### ❌ Mixed-Type Documents
```
# Bad: "User Authentication Guide"
- What authentication is (explanation)
- How to set up auth (tutorial)
- Login API reference (reference)  
- Troubleshooting auth (how-to)
```

### ✅ Separate Documents
```
# Good: 4 separate documents
- Tutorial: "Add authentication to your app"
- How-to: "Fix common auth problems"
- Reference: "Authentication API"
- Explanation: "Why we chose JWT authentication"
```

### ❌ Tutorials That Don't Work
- Missing prerequisites
- Steps that fail
- No clear end result
- Too much explanation

### ❌ How-to Guides That Start from Zero
- Explaining basic concepts
- Starting with installation
- Teaching instead of solving

### ❌ Reference Docs with Opinions
- Explaining why decisions were made
- Including tutorials
- Personal preferences

### ❌ Explanations with Step-by-Step Instructions
- Mixing concepts with actions
- Tutorial-like structure
- Immediate action items

## Tools That Support This Structure

### Static Site Generators
- **Docusaurus**: Built-in sidebar organization
- **VuePress**: Easy categorization
- **GitBook**: Natural fit for 4-quadrant structure
- **MkDocs**: Plugin support for organization

### Documentation Platforms
- **Notion**: Database-driven organization
- **Confluence**: Space-based separation
- **GitHub Wiki**: Simple folder structure
- **README-driven**: Basic but effective

### Validation Tools
- **Vale**: Style guide enforcement
- **Alex**: Inclusive language checking
- **Textlint**: Custom rule validation
- **Grammarly**: Grammar and clarity

## Success Metrics

### For Tutorials
- Completion rate >80%
- Time to complete matches estimate
- New user activation rate
- Support ticket reduction

### For How-to Guides
- Search query success rate
- Problem resolution time
- Reduced repeat questions
- User satisfaction scores

### For Reference
- API/function lookup speed
- Documentation coverage
- Accuracy (no outdated info)
- Usage frequency

### For Explanations
- Architecture understanding surveys
- Developer onboarding feedback
- Decision-making speed
- Team alignment

## Quick Reference Card

| Type | User Need | Format | Success Measure |
|------|-----------|--------|----------------|
| **Tutorial** | "I want to learn" | Step-by-step lesson | Beginners can complete it |
| **How-to** | "I have a problem" | Goal-oriented steps | Solves specific issues |
| **Reference** | "I need to look this up" | Structured information | Fast, accurate lookup |
| **Explanation** | "I want to understand" | Discursive discussion | Improves comprehension |

## Getting Help

### When Your Documentation Isn't Working
1. **Users can't complete tutorials** → Test with real beginners
2. **Same questions keep coming up** → Add relevant how-to guides
3. **People can't find information** → Improve reference organization
4. **Team makes inconsistent decisions** → Add more explanations

### Community Resources
- Original Diátaxis site: https://diataxis.fr/
- Divio documentation: https://docs.divio.com/documentation-system/
- Community examples and templates
- Documentation testing tools

---

*This starter kit provides a practical foundation for implementing the Divio Documentation System in early-to-mid stage projects. Focus on clear separation of the 4 types and user needs over perfect completeness.*